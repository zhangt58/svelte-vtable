<script>
  import { Badge } from 'flowbite-svelte';
  import { ChevronDownOutline, ArrowDownOutline } from 'flowbite-svelte-icons';
  import { onDestroy } from 'svelte';

  // shared default no-op function
  const DEFAULT_NOOP = (..._args) => {};

  // Props using Svelte 5 $props()
  let {
    // columnFilters: array of { key, label, uniqueValues }
    // where uniqueValues is an array of unique values for that column
    columnFilters = [],
    // layout direction: 'horizontal' or 'vertical'
    direction = 'horizontal',
    // current active filters: { columnKey: [selectedValues] }
    activeFilters = {},
    // Callback when filters change
    filterChange = DEFAULT_NOOP,
    // Optional callback when sort mode/dir changes: ( { columnKey, mode, dir } )
    sortChange = DEFAULT_NOOP,
    // CSS class for the container
    className = '',
    // Whether to show filter counts
    showCounts = true,
    // Virtualization props (defaults)
    virtualThreshold = 500,
    virtualItemHeight = 36,
    virtualOverscan = 5,
    // Debounce milliseconds for emitting filterChange (0 = immediate)
    emitDebounce = 100,
    // If the number of options exceeds this threshold, the options are not generated by default
    // and the user must click "Load options" to populate them. Set to 0 to always populate.
    populateThreshold = 100
  } = $props();

  // Internal state for selected options per column
  let selections = $state({});

  // Track whether options have been loaded (populated) per-column when the list is large
  let loadedOptions = $state({});

  // Auto-enable loading for small lists when columnFilters change
  $effect(() => {
    const initial = {};
    for (const col of columnFilters) {
      const len = Array.isArray(col.uniqueValues) ? col.uniqueValues.length : 0;
      initial[col.key] = (populateThreshold <= 0) || len <= populateThreshold;
    }
    loadedOptions = initial;
  });

  // --- Debounced emission helpers ---
  let _emitTimer = null;
  let _pendingEmit = null;

  function scheduleEmit(columnKey, selectedValues) {
    // capture latest state snapshot
    _pendingEmit = { columnKey, selectedValues, allFilters: selections };

    if (!emitDebounce || emitDebounce <= 0) {
      // immediate
      flushEmit();
      return;
    }

    if (_emitTimer) clearTimeout(_emitTimer);
    _emitTimer = setTimeout(() => flushEmit(), emitDebounce);
  }

  function flushEmit() {
    if (!_pendingEmit) return;
    const payload = _pendingEmit;
    _pendingEmit = null;
    if (_emitTimer) {
      clearTimeout(_emitTimer);
      _emitTimer = null;
    }

    try {
      (/** @type {any} */ (filterChange))(payload);
    } catch (err) {
      try { console.error('filterChange threw:', err); } catch (e) {}
    }
  }

  // cleanup on destroy to avoid timers running after unmount
  onDestroy(() => {
    if (_emitTimer) clearTimeout(_emitTimer);
    // flush any pending emit synchronously
    flushEmit();
  });

  // Initialize selections from activeFilters
  $effect(() => {
    const newSelections = {};
    for (const col of columnFilters) {
      newSelections[col.key] = activeFilters[col.key] || [];
    }
    selections = newSelections;
  });

  // Toggle selection for a specific column and value
  function toggleSelection(columnKey, value) {
    const current = selections[columnKey] || [];
    let updated;

    if (current.includes(value)) {
      // Remove the value
      updated = current.filter(v => v !== value);
    } else {
      // Add the value
      updated = [...current, value];
    }

    selections = { ...selections, [columnKey]: updated };

    // Schedule debounced filter change emission
    scheduleEmit(columnKey, updated);
  }

  // Clear all selections for a column
  function clearColumn(columnKey) {
    selections = { ...selections, [columnKey]: [] };
    scheduleEmit(columnKey, []);
  }

  // Clear all filters
  function clearAllFilters() {
    const cleared = {};
    for (const col of columnFilters) {
      cleared[col.key] = [];
    }
    selections = cleared;

    // emit after debounce (columnKey null indicates global clear)
    scheduleEmit(null, []);
  }

  // Check if any filters are active
  const hasActiveFilters = $derived(() => {
    return Object.values(selections).some(arr => arr && arr.length > 0);
  });

  // Count active filters
  const activeFilterCount = $derived(() => {
    return Object.values(selections).reduce((sum, arr) => sum + (arr?.length || 0), 0);
  });

  // Toggle dropdown visibility for a column
  let openDropdowns = $state({});

  // Simple toggle/close functions â€” dropdowns are controlled only by their
  // toggle button and programmatic calls (e.g. Show All / Collapse All).
  function toggleDropdown(columnKey) {
    const wasOpen = openDropdowns[columnKey];
    openDropdowns = { ...openDropdowns, [columnKey]: !wasOpen };
  }

  // Sorting state for each column's dropdown
  let sortModes = $state({});
  // Per-column sort direction: 'asc' or 'desc'
  let sortDirs = $state({});

  // Inline header search queries per column (small text filter for options)
  let searchQueries = $state({});

  // --- Virtualization settings and state ---
  // (virtual props are provided via the main $props() destructure above)

  // DOM refs for per-column scroll containers
  let listRefs = $state({});

  // Per-column scroll state: { scrollTop, height }
  let virtualScroll = $state({});

  // Svelte action to register list containers and keep virtualScroll updated
  function registerList(node, params) {
    const key = params && params.key;
    if (!key) return { destroy() {} };

    listRefs = { ...listRefs, [key]: node };

    function updateState() {
      virtualScroll = {
        ...virtualScroll,
        [key]: { scrollTop: node.scrollTop, height: node.clientHeight }
      };
    }

    // initialize
    updateState();

    const onScroll = () => updateState();
    const onResize = () => updateState();

    node.addEventListener('scroll', onScroll);
    // Observe size changes (in case container height changes)
    const ro = new ResizeObserver(onResize);
    ro.observe(node);

    return {
      update(newParams) {
        // allow key to be updated (unlikely)
        if (!newParams || newParams.key !== key) {
          node.removeEventListener('scroll', onScroll);
          ro.disconnect();
          delete listRefs[key];
        }
      },
      destroy() {
        node.removeEventListener('scroll', onScroll);
        ro.disconnect();
        delete listRefs[key];
        // remove virtualScroll entry
        const copy = { ...virtualScroll };
        delete copy[key];
        virtualScroll = copy;
      }
    };
  }

  // Compute virtual slice for a column when the values exceed threshold
  function getVirtualSlice(column, values) {
    if (!values || values.length <= virtualThreshold) return null;
    const vs = virtualScroll[column.key] || { scrollTop: 0, height: 200 };
    const itemH = virtualItemHeight;
    const height = vs.height || 200;
    const overscan = virtualOverscan;

    const start = Math.max(0, Math.floor(vs.scrollTop / itemH) - overscan);
    const visibleCount = Math.ceil(height / itemH) + overscan * 2;
    const end = Math.min(values.length, start + visibleCount);
    const slice = values.slice(start, end);
    const top = start * itemH;
    const totalHeight = values.length * itemH;

    return { slice, start, end, top, totalHeight };
  }

  // --- Helper: return the values for a column after applying search + sort ---
  function getSortedValues(column) {
    // column.uniqueValues is expected to be an array of possible values
    const raw = Array.isArray(column.uniqueValues) ? column.uniqueValues.slice() : [];

    // apply search filter if present
    const q = (searchQueries[column.key] || '').toString().trim().toLowerCase();
    let filtered = raw;
    if (q) {
      filtered = raw.filter(v => {
        const text = v === null || v === undefined ? '(empty)' : String(v);
        return text.toLowerCase().includes(q);
      });
    }

    // determine sort mode and direction
    const mode = sortModes[column.key] || 'name';
    const dir = (sortDirs[column.key] || 'asc') === 'asc' ? 1 : -1;

    // stable sort: map-index technique
    const withIndex = filtered.map((v, i) => ({ v, i }));

    withIndex.sort((a, b) => {
      const va = a.v;
      const vb = b.v;

      if (mode === 'count' && column.counts) {
        const ca = Number(column.counts[va] ?? 0);
        const cb = Number(column.counts[vb] ?? 0);
        if (ca !== cb) return (ca - cb) * dir * -1; // higher counts first when desc
        // fallback to name compare
      }

      // compare by name
      const sa = va === null || va === undefined ? '(empty)' : String(va);
      const sb = vb === null || vb === undefined ? '(empty)' : String(vb);
      const la = sa.toLowerCase();
      const lb = sb.toLowerCase();
      if (la < lb) return -1 * dir;
      if (la > lb) return 1 * dir;
      // maintain stable order
      return a.i - b.i;
    });

    return withIndex.map(x => x.v);
  }

  // Toggle sort mode for a column. If the same mode is clicked again,
  // flip the direction; otherwise set the mode and default to 'desc'.
  function toggleSortMode(columnKey, mode) {
    const prevMode = sortModes[columnKey];
    if (prevMode === mode) {
      // flip direction
      const prevDir = sortDirs[columnKey] || 'desc';
      const nextDir = prevDir === 'asc' ? 'desc' : 'asc';
      sortDirs = { ...sortDirs, [columnKey]: nextDir };
    } else {
      sortModes = { ...sortModes, [columnKey]: mode };
      // default first click to descending (common expectation for counts)
      sortDirs = { ...sortDirs, [columnKey]: 'desc' };
    }
    // ensure the mode is set (for first-time clicks)
    sortModes = { ...sortModes, [columnKey]: mode };

    const newDir = sortDirs[columnKey] || 'asc';
    try {
      // notify parent if it wants to react to sort changes
      (/** @type {any} */ (sortChange))({ columnKey, mode, dir: newDir });
    } catch (err) {
      try { console.debug('sortChange callback threw', err); } catch (e) {}
    }
    // debug log
    try { console.debug('toggleSortMode', columnKey, mode, sortDirs[columnKey]); } catch (e) {}
  }

  // Clear selection for a column (from within dropdown)
  function clearSelection(columnKey) {
    clearColumn(columnKey);
  }

  // Check all values for a column
  function checkAll(columnKey, values) {
    const all = Array.isArray(values) ? values.slice() : [];
    selections = { ...selections, [columnKey]: all };
    scheduleEmit(columnKey, all);
  }

  // Invert selection for a column (values is the full option list)
  function invertSelection(columnKey, values) {
    const current = new Set(selections[columnKey] || []);
    const next = [];
    for (const v of (Array.isArray(values) ? values : [])) {
      if (!current.has(v)) next.push(v);
    }
    selections = { ...selections, [columnKey]: next };
    scheduleEmit(columnKey, next);
  }

  // Uncheck all -> reuse clearColumn
  function checkNone(columnKey) {
    clearColumn(columnKey);
  }

  // Show all dropdowns
  function showAllDropdowns() {
    const allOpen = {};
    for (const col of columnFilters) {
      allOpen[col.key] = true;
    }
    openDropdowns = allOpen;
  }

  // Collapse all dropdowns
  function collapseAllDropdowns() {
    openDropdowns = {};
  }

  // Check if all dropdowns are open
  const allDropdownsOpen = $derived.by(() => {
    return columnFilters.every(col => openDropdowns[col.key]);
  });

  // Check if all dropdowns are closed
  const allDropdownsClosed = $derived.by(() => {
    return columnFilters.every(col => !openDropdowns[col.key]);
  });
</script>

<div class="p-2 bg-gray-50 rounded-md border border-gray-200 dark:bg-gray-800 dark:border-gray-700 {className}"
     class:horizontal={direction === 'horizontal'} class:vertical={direction === 'vertical'}>
  <div class="flex justify-between items-center mb-2 flex-wrap gap-1">
    <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100 m-0">Filters</h3>
    <div class="flex items-center gap-1 flex-wrap">
      {#if hasActiveFilters()}
        <div class="flex items-center gap-1">
          <Badge color="blue" rounded>{activeFilterCount()} active</Badge>
          <button
            class="px-3 py-1 text-sm text-red-600 bg-transparent border border-red-600 rounded-md hover:bg-red-600 hover:text-white transition-all cursor-pointer"
            onclick={clearAllFilters}
            title="Clear all filters"
          >
            Clear All
          </button>
        </div>
      {/if}
      <button
        class="px-3 py-1 text-sm text-green-600 bg-transparent border border-green-600 rounded-md hover:bg-green-600 hover:text-white transition-all cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent disabled:hover:text-green-600"
        disabled={allDropdownsOpen}
        onclick={showAllDropdowns}
        title="Show all filter dropdowns"
      >
        Show All
      </button>
      <button
        class="px-3 py-1 text-sm text-gray-600 bg-transparent border border-gray-600 rounded-md hover:bg-gray-600 hover:text-white transition-all cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent disabled:hover:text-gray-600"
        disabled={allDropdownsClosed}
        onclick={collapseAllDropdowns}
        title="Close all filter dropdowns"
      >
        Close All
      </button>
    </div>
  </div>

  <div class="grid gap-2" class:grid-horizontal={direction === 'horizontal'} class:grid-vertical={direction === 'vertical'}>
    {#each columnFilters as column (column.key)}
      {@const isActive = selections[column.key]?.length > 0}
      {@const isOpen = openDropdowns[column.key]}
      {@const sortedValues = getSortedValues(column)}
      {@const currentSortMode = sortModes[column.key] || 'name'}
      {@const currentSortDir = sortDirs[column.key] || 'asc'}

      <div class="flex flex-col min-w-0 relative">
        <button
          id="filter-{column.key}"
          class="w-full flex justify-between items-center px-3 py-2 text-sm text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md hover:border-gray-400 dark:hover:border-gray-500 focus:outline-none focus:border-blue-500 dark:focus:border-blue-400 focus:ring-2 focus:ring-blue-100 dark:focus:ring-blue-900 transition-all cursor-pointer gap-2 {isActive ? 'border-green-500 dark:border-green-400 bg-green-50 dark:bg-green-900/20' : ''}"
          onclick={() => toggleDropdown(column.key)}
          type="button"
        >
          <span class="flex-1 text-left whitespace-nowrap overflow-hidden text-ellipsis min-w-0">
              {column.label || column.key}
          </span>
          {#if isActive}
            <Badge color="green" rounded class="ml-1">{selections[column.key].length}</Badge>
          {/if}
          <ChevronDownOutline class="w-5 h-5 shrink-0 transition-transform {isOpen ? 'rotate-180' : ''}" />
        </button>

        {#if isOpen}
          <div
            class="absolute top-full mt-1 left-0 right-0 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-lg dark:shadow-gray-900 max-h-64 flex flex-col dropdown-menu"
            tabindex="-1"
            data-column={column.key}
          >
            <div class="px-1 py-1 border-b border-gray-200 dark:border-gray-600">
              <div class="flex items-center gap-1 w-full min-w-0">
                <input
                  type="text"
                  placeholder="Filter..."
                  class="p-1 flex-1 min-w-0 px-2 py-1 text-xs border border-gray-200 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-200 focus:outline-none focus:border-blue-500"
                  bind:value={searchQueries[column.key]}
                />

                <div class="flex items-center gap-1">
                  <button
                    class="p-0.5 flex-1 flex items-center justify-center gap-1 text-sm text-gray-600 dark:text-gray-400 bg-transparent border border-gray-200 dark:border-gray-700 rounded hover:bg-gray-100 dark:hover:bg-gray-700 hover:border-gray-300 dark:hover:border-gray-600 hover:text-gray-700 dark:hover:text-gray-300 transition-all"
                    class:bg-blue-100={currentSortMode === 'name'}
                    class:dark:bg-blue-900={currentSortMode === 'name'}
                    onclick={() => toggleSortMode(column.key, 'name')}
                    title="Sort by name"
                    type="button"
                  >
                    <span class="text-sm font-semibold">Aa</span>
                    <ArrowDownOutline
                      class={"w-3 h-3 transition-transform " + (currentSortMode === 'name' ? 'text-blue-900 dark:text-blue-100' : 'text-gray-400 dark:text-gray-500')}
                      style={currentSortMode === 'name' && currentSortDir === 'asc' ? 'transform: rotate(180deg);' : ''}
                      aria-hidden="true"
                    />
                  </button>

                  {#if showCounts && column.counts}
                    <button
                      class="p-0.5 flex-1 flex items-center justify-center gap-1 text-sm text-gray-600 dark:text-gray-400 bg-transparent border border-gray-200 dark:border-gray-700 rounded hover:bg-gray-100 dark:hover:bg-gray-700 hover:border-gray-300 dark:hover:border-gray-600 hover:text-gray-700 dark:hover:text-gray-300 transition-all"
                      class:bg-blue-100={currentSortMode === 'count'}
                      class:dark:bg-blue-900={currentSortMode === 'count'}
                      onclick={() => toggleSortMode(column.key, 'count')}
                      title="Sort by count"
                      type="button"
                    >
                      <span class="text-sm font-semibold">#</span>
                      <ArrowDownOutline
                        class={"w-3 h-3 transition-transform " + (currentSortMode === 'count' ? 'text-blue-900 dark:text-blue-100' : 'text-gray-400 dark:text-gray-500')}
                        style={currentSortMode === 'count' && currentSortDir === 'asc' ? 'transform: rotate(180deg);' : ''}
                        aria-hidden="true"
                      />
                    </button>
                  {/if}


                </div>

              </div>
            </div>

            <!-- Action row: Check all / Invert / Uncheck all (icon buttons) -->
            <div class="px-2 py-1 border-b border-gray-100 dark:border-gray-600">
              <div class="flex items-center justify-between">
                <div class="flex items-center gap-1">
                  <button
                    type="button"
                    class="p-1 rounded-md flex items-center gap-1 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    onclick={() => checkAll(column.key, sortedValues)}
                    disabled={sortedValues.length === 0}
                    aria-label="Check all"
                    title="Check all"
                  >
                    <!-- Checked square icon (higher contrast) -->
                    <svg class="w-4 h-4 text-gray-800 dark:text-white" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                      <rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" stroke-width="2.5" fill="none" />
                      <path d="M7 13l3 3 7-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none" />
                    </svg>
                    <span class="text-sm text-gray-800 dark:text-gray-100 select-none">All</span>
                  </button>

                  <button
                    type="button"
                    class="p-1 rounded-md flex items-center gap-1 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    onclick={() => invertSelection(column.key, sortedValues)}
                    disabled={sortedValues.length === 0}
                    aria-label="Invert selection"
                    title="Invert selection"
                  >
                    <!-- Half-checked square icon (left half filled) - higher contrast -->
                    <svg class="w-4 h-4 text-gray-800 dark:text-white" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                      <rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" stroke-width="2.5" fill="none" />
                      <rect x="4" y="4" width="8.5" height="16" fill="currentColor" opacity="0.28" stroke="none" />
                      <path d="M7 13l3 3 7-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none" />
                    </svg>
                    <span class="text-sm text-gray-800 dark:text-gray-100 select-none">Invert</span>
                  </button>

                  <button
                    type="button"
                    class="p-1 rounded-md flex items-center gap-1 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    onclick={() => checkNone(column.key)}
                    disabled={sortedValues.length === 0}
                    aria-label="Uncheck all"
                    title="Uncheck all"
                  >
                    <!-- Empty square icon (higher contrast stroke) -->
                    <svg class="w-4 h-4 text-gray-800 dark:text-white" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                      <rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" stroke-width="2" fill="none" />
                    </svg>
                    <span class="text-sm text-gray-800 dark:text-gray-100 select-none">None</span>
                  </button>
                </div>

                <div class="pr-1">
                  <Badge color="blue" rounded title="Total options">{sortedValues.length}</Badge>
                </div>
              </div>
            </div>

            <div class="p-1 overflow-y-auto flex-1" use:registerList={{ key: column.key }}>
              {#if sortedValues.length > populateThreshold && !loadedOptions[column.key]}
                <div class="p-1 text-sm text-gray-700 dark:text-gray-200">
                  Too many options ({sortedValues.length}) to render by default.
                  <button
                    class="ml-2 px-2 py-1 text-xs rounded bg-gray-100 dark:bg-gray-600 text-gray-800 dark:text-white border border-gray-200 hover:bg-gray-200 dark:hover:bg-gray-500"
                    type="button"
                    onclick={() => loadedOptions = { ...loadedOptions, [column.key]: true }}
                  >
                    Load options
                  </button>
                </div>
              {:else}
                {#if sortedValues.length > virtualThreshold}
                  {@const v = getVirtualSlice(column, sortedValues)}

                  <div style="height:{v.totalHeight}px; position:relative;">
                    <div style="position:absolute; top:{v.top}px; left:0; right:0;">
                      {#each v.slice as value, idx (idx)}
                        {@const isSelected = selections[column.key]?.includes(value)}
                        {@const displayValue = value === null || value === undefined ? '(empty)' : String(value)}

                        <label class="flex items-center gap-1 px-2 py-1 cursor-pointer rounded-sm hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors" style="height:{virtualItemHeight}px; box-sizing:border-box;">
                          <input
                            type="checkbox"
                            checked={isSelected}
                            onchange={() => toggleSelection(column.key, value)}
                            class="w-4 h-4 shrink-0 cursor-pointer accent-blue-500"
                          />
                          <span class="flex-1 text-sm text-gray-700 dark:text-gray-300 select-none min-w-0 overflow-hidden text-ellipsis">{displayValue}</span>
                          {#if showCounts && column.counts && column.counts[value] !== undefined}
                            <span class="text-xs text-gray-500 dark:text-gray-400 ml-auto shrink-0">({column.counts[value]})</span>
                          {/if}
                        </label>
                      {/each}
                    </div>
                  </div>

                {:else}
                  {#if sortedValues.length > 0}
                    {#each sortedValues as value, idx (idx)}
                      {@const isSelected = selections[column.key]?.includes(value)}
                      {@const displayValue = value === null || value === undefined ? '(empty)' : String(value)}

                      <label class="flex items-center gap-1 px-2 py-1 cursor-pointer rounded-sm hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors">
                        <input
                          type="checkbox"
                          checked={isSelected}
                          onchange={() => toggleSelection(column.key, value)}
                          class="w-4 h-4 shrink-0 cursor-pointer accent-blue-500"
                        />
                        <span class="flex-1 text-sm text-gray-700 dark:text-gray-300 select-none min-w-0 overflow-hidden text-ellipsis">{displayValue}</span>
                        {#if showCounts && column.counts && column.counts[value] !== undefined}
                          <span class="text-xs text-gray-500 dark:text-gray-400 ml-auto shrink-0">({column.counts[value]})</span>
                        {/if}
                      </label>
                    {/each}
                  {:else}
                    <div class="p-4 text-center text-sm text-gray-400 dark:text-gray-500">No values available</div>
                  {/if}
                {/if}
              {/if}
            </div>
          </div>
        {/if}
        </div>
      {/each}
  </div>
</div>

<style>
  /* Grid layout classes */
  .grid-horizontal {
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  }

  .grid-vertical {
    grid-template-columns: 1fr;
  }

  /* Dropdown menu positioning */
  .dropdown-menu {
    z-index: 9999;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .grid-horizontal {
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    }
  }

  @media (max-width: 640px) {
    .grid-horizontal {
      grid-template-columns: 1fr;
    }
  }
</style>
